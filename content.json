{"meta":{"title":"WPY's Android Tour","subtitle":"Computer","description":"android开发与开源框架源码学习，java，kotlin等语言学习，linux操作系统","author":"messi-wpy","url":"https://messi-wpy.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-11-08T08:40:07.000Z","updated":"2019-11-08T08:57:07.436Z","comments":true,"path":"categories/index.html","permalink":"https://messi-wpy.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-08T08:59:39.000Z","updated":"2019-11-08T08:59:39.672Z","comments":true,"path":"about/index.html","permalink":"https://messi-wpy.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-08T08:40:30.000Z","updated":"2019-11-08T08:58:35.896Z","comments":true,"path":"tags/index.html","permalink":"https://messi-wpy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android自定义view-onMeasure","slug":"Android自定义view-onMeasure","date":"2019-11-25T15:38:36.000Z","updated":"2019-11-25T15:38:36.912Z","comments":true,"path":"2019/11/25/Android自定义view-onMeasure/","link":"","permalink":"https://messi-wpy.github.io/2019/11/25/Android%E8%87%AA%E5%AE%9A%E4%B9%89view-onMeasure/","excerpt":"","text":"Andorid view 的onMeasure（）：1234@Overrideprotected void onMeasure(int widthMeasureSpec,int heightMeasureSpec)&#123; super.onMeasure(widthMeasureSpec,heightMeasureSpec);&#125; 1. 理解MeasureSpec从onMeasure方法参数可以看到两个int值，那么怎么通过他来获取测量信息呢？其实MeasureSpec是一view的内部类，其封装了view的规格尺寸。他有一个很重要的常量，就是一个32位的int 值，很巧妙，其中高2位代表了SpecMode，低30位代表了SpecSIze，（从其源码可以看出） SpecMode 指测量模式： UNSPECIFIED：未指定模式未指定模式，View想多大就多大，父容器不做限制，一般用于系统内部的测量 AT_MOST:最大模式，对应于wrap_comtent属性，子View的最终大小是父View指定的SpecSize值，并且子View的大小不能大于这个值。 EXACTLY：精确模式，对应于 match_parent 属性和具体的数值，父容器测量出 View所需要的大小，也就是SpecSize的值 所以一般自定义view需要重写该方法，给出当测量模式为AT_MOST时的默认宽高大小，否则，当设置其宽高为wrap_content时会和match_parent一样 2.view的Measure流程：measure 用来测量 View 的宽和高，它的流程分为 View 的 measure 流程和 ViewGroup 的measure流程，只不过ViewGroup的measure流程除了要完成自己的测量，还要遍历地调用子元素的measure（）方法。在自定义view的时候，一般需要处理padding和子元素的margin两种情况 3.两种获取view的宽高方法对比： getMeasuredWidth() 123public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK;&#125; getHeight() 123public final int getHeight() &#123; return mBottom - mTop;&#125; 所以从其源码可以看出不同，第一个需要在其onMeasure()方法调用后才能获取到正确的宽高，而第二个需要在onLayout()调用后才能获取到","categories":[],"tags":[]},{"title":"Android自定义view练习","slug":"Android自定义view练习","date":"2019-11-22T07:18:54.000Z","updated":"2019-11-22T07:20:54.969Z","comments":true,"path":"2019/11/22/Android自定义view练习/","link":"","permalink":"https://messi-wpy.github.io/2019/11/22/Android%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%BB%83%E4%B9%A0/","excerpt":"","text":"Android自定义view练习1. 自定义view的四个构造方法： 第一个public View(Context context)：这是在activity或其他中直接创建 new时，调用该构造方法，只需要传入context，所以他的属性可以根据提供的各种set***()方法去设置 第二个public View(Context context, AttributeSet attrs)这是时当声明在xml文件中，系统在解析这个XML布局的时候调用，可以从attrs这个数组中获取在xml中声明的各种属性， 第三个 public View(Context context, AttributeSet attrs, int defStyleAttrs)这个比第二个多出了一个defStyleAttrs，顾名思义，这是一个style，获取当前主题中声明的这个自定义view的style，所以，同个它可以实现不同主题有不同的显示效果。这个构造函数通常是通过第二个构造函数调用，如：12345//注意，调用的是this（）也就是你写的第三个构造函数 , 而不是super（），否则就不会调用你自己的第三个构造函数了 public CircleView(Context context, @Nullable AttributeSet attrs) &#123; this(context,attrs, R.attr.SimpleCircleStyle); &#125; 同时通过其注释: @param defStyleAttr An attribute in the current theme that contains a reference to a style resource that supplies default values for the view. Can be 0 to not look for defaults. 可看出，要想不让他通过主题里的这个view的style获取默认值，只需把他设置 defStyleAttr=0即可。再进一步，其实第二个构造函数的实现就是调用了第三个： 1234public View(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0);&#125; 第四个public CircleView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes)@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)(21)这个需要api21，相对于第三个多了defStyleRes，所以这是说明你可以新建一个style，然后用他去代替主题里的这个view的default style，那为什么要这样做呢？Theme是全局控制样式的，但是时候我们只想为某几个TextView单独定义样式，那就得使用四个参数的构造函数。所以你需要新建一个继承他，然后第二个构造函数调用第三个，defStyleAttr传入0，第三个构造函数再继续调用第四个，defStyleRes传入你自定义的style。 总结： 其实这四个构造函数是相关联的，使用中只会直接调用第一个，或者第二个构造函数；第四个通过第三个调用，第三个通过第二个调用。 优先顺序：不管通过哪个获取，都是一个函数：obtainStyledAttributes( AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)优先顺序： 在布局xml中直接定义 &gt; 在布局xml中通过style定义 &gt; 自定义View所在的Activity的Theme中指定style引用 &gt; 构造函数中defStyleRes指定的默认值 使用： 添加自定义属性在res/values/目录下增加一个resources xml文件,示例如下(res/values/attrs_my_custom_view.xml):1234&lt;declare-styleable name=&quot;CircleView&quot;&gt; &lt;attr name=&quot;circleColor&quot; format=&quot;color|reference&quot;/&gt; &lt;/declare-styleable&gt; 设置在主题中的style：需要先声明一个attr：&lt;attr name=&quot;SimpleCircleStyle&quot; format=&quot;reference&quot;/&gt;然后在当前主题中为其赋值：&lt;item name=&quot;SimpleCircleStyle&quot;&gt;@style/SimpleCircleStyle&lt;/item&gt;（值为你自定义的一个style） attrs.xml文件中属性类型format值的格式1234567891011121314&quot;reference&quot; //引用 &quot;color&quot; //颜色 &quot;boolean&quot; //布尔值 &quot;dimension&quot; //尺寸值 &quot;float&quot; //浮点值 &quot;integer&quot; //整型值 &quot;string&quot; //字符串 &quot;fraction&quot; //百分数,比如200% //枚举类型：&lt; attr name=&quot;orientation&quot;&gt; &lt; enum name=&quot;horizontal&quot; value=&quot;0&quot; /&gt; &lt; enum name=&quot;vertical&quot; value=&quot;1&quot; /&gt; &lt; /attr&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://messi-wpy.github.io/tags/android/"}]},{"title":"Android view的事件分发机制","slug":"android View的事件分发机制","date":"2019-11-11T16:00:00.000Z","updated":"2019-11-24T12:38:48.036Z","comments":true,"path":"2019/11/12/android View的事件分发机制/","link":"","permalink":"https://messi-wpy.github.io/2019/11/12/android%20View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Android 自定义viewAndroid自定义view有如下步骤： 创建view（View子类） 处理view的布局 绘制view 与用户进行交互 android view视图层次 view的事件分发机制(与用户进行交互)：MotionEvent事件分发主要传递的其实就是一系列MotionEvent，看一下他的主要方法： getX()/getY()获取该触摸点相对于当前view的左上角坐标 getRawX()/getRawY()获取触摸点相对于整个手机屏幕的坐标 getAction()获取事件类型 事件分发就是将一个MotionEvent传递给一个具体的view。事件传递的主要过程：activity—&gt;window—-&gt;viewgroup(view) 事件分发三大方法：boolean dispatchTouchEvent(MotionEvent ev) 事件分发的主要方法 如果事件能够传递给当前view，那么他的dispatchTouchEvent方法一定会被调用 伪代码描述： 1234567891011public boolean onDispatchTouchEvent(MotionEvent ev)&#123; boolean result=false; if(onInterceptTouchEvent(ev))&#123; //也就是调用了view的方法，viewgroup继承自view result=onTouchEvent; &#125;else&#123; result=child.dispatchTouchEvent(ev) &#125; return result;&#125; 优先级顺序 (view)的dispatchTouchEvent—&gt;onTouch()—-&gt;onTouchEvent()—–&gt;onclick() boolean onInterceptTouchEvent(MotionEvent ev)表示是否拦截此次事件 ，默认返回falseboolean onTouchEvent(MotionEvent ev)处理触摸事件的主要方法，（如果设置有onTouchListener设置了onTouch，则会调用onTouch，且返回true则不会调用onTouchEvent)，里面调用了onClick,onLongClick,(且只要LONG_CLICKABLE或者CLICKABLE这两个任意一个为true，就会返回true)，即便是不可用状态 dispatchTouchEvent主要流程（一次viewGroup到view的传递过程，其他的也是这样，递归着来）： (viewGroup)判断是否拦截,如果拦截 （onterceptTouchEvent返回true），则接下来的事件序列都有其来处理（调用他的onTouchEvent），否则进行下一步 遍历viewGroup里所有的子view（viewGroup），找到符合的view（在点击坐标是否在view内，且view是否在播放动画），如果找到，则调用他的dispatch方法，即完成一次传递（通过dispatchTransformedTouchEvent()） 如果遍历所有子元素后事件都没有被处理，则包含两种情况: viewgroup没有合适子元素 子元素处理了点击事件，但dispatchTouchEvent返回了false（一般是onTouchEvent返回了false） 则继续交由该viewgroup处理 总结一下： 一但viewGroup拦截了这个事件，则这一整个序列都将交由他来处理，并且不会再次调用onInterceptTouchEvent（）方法。所以如果viewGroup想要处理事件，就一是拦截了事件，二是没有找到合适的子view，从而转去调用它自己的onTouchEvent。 view一旦开始处理事件，如果他不消耗ACTION_DOWN,则其他事件也不会交由他处理，view如果不消耗除了ACTION_DOWN以外的其他事件，则这事件会消失，最后将传到activity处理 注意onclick的调用时机是view接收到了ACTION_DOWN和ACTION_UP这两个事件。 onInterceptTouchEvent的调用：12345678910111213141516// ViewGroup if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 也就是说如果被拦截，那么mfirstTouchTarget就为null，则跳出去，就不会再次执行onInterceptTouchEvent,所以一定注意这个方法只会执行一次。 disallowIntercept 而且从上面一段源码也可看到有一个特殊的标记量disallowIntercept，这个变量可以由requestDisallowInterceptTouchEvent()设置，他可以不允许viewgroup拦截事件，所以，如果disallowIntercept==true，就直接跳过，不执行 onInterceptTouchEvent(ev)，他的作用是可以由子view去调用getParent().requestDisallowInterceptTouchEvent(true);从而处理滑动冲突 总的来说，view的事件传递就是利用了责任链设计模式，从activity开始忘viewGroup，再往下级view传递，（从DOWN开始，down事件确定了该view是否要消费他）如果能执行，能消费，则该view返回true，表示交由他来处理，并且停止向下传递；而如果返回了false则交由上级view来处理，而上级viewgroup可以拦截下事件，从而将接下来的事件交由他来处理。","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/tags/Android/"}]},{"title":"Android线程通信机制","slug":"Android线程通信","date":"2019-10-20T16:00:00.000Z","updated":"2019-11-16T10:27:20.566Z","comments":true,"path":"2019/10/21/Android线程通信/","link":"","permalink":"https://messi-wpy.github.io/2019/10/21/Android%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"Android中的线程通信前言：Android开发中我们经常遇到需要切换线程的场景，当进行网络请求，数据库查询（在google新出的jetpack room数据库框架中，强制数据库操作都在新线程上，如果在主线程会抛出异常），文件读写等耗时操作都要新建线程，然后在将结果返回到主线程上。或者想在另一个线程上运行一段代码，这些都是线程间的通信。 但不管你使用何种方式实现：直接使用handle传递信息，使用asynctask，甚至使用rxjava的subscribeon() ,其底层都是通过Android 的handle机制来实现的所以接下来就来探索这一实现过程。 线程共享变量：刚学过操作系统的我们知道：在同一进程中线程和线程之间资源是共享的，也就是对于任何变量在任何线程都是可以访问和修改的（注意这是在操作系统层面，因为所以线程共用一个进程的资源，但在语言层面，会有局部变量，全局变量的约束，而原则上只要你能找到变量的地址，你就能在任何线程上使用）。 这样一来就好实现了，只需访问所需传递信息的线程的handle就行了，调用handle.send。Android将线程间传递的信息封装成了一个Message类，数据可以传递给Message的object（或复杂一点的bundle字段），调用post（）传递代码段其实被封装成了Message的Runnable callback（把代码块当成对象传递）。 线程接收信息了解了Android线程如何向另一个线程传递信息，那接收信息的线程如何处理呢？，另一个主角looper就要登场了。 12345678910 (Looper源码) ... Looper.prepar()android.os.Handler handler = new Handler()&#123; @Override public void handleMessage(final Message msg) &#123; //这里接受并处理消息 &#125;&#125;;Looper.loop() 调用这段代码将一个普通线程变成looper线程，looper会不断从其Messagequeue中获取Message传递给这个handle处理(Looper.loop()这个方法其实是个死循环)，这个Messagequeue其实是一个阻塞队列，队列中没有东西时会阻塞当前线程。 12345678looper.loop()主要代码 for (;;) &#123; ... Message msg = queue.next(); ... msg.target.dispatchMessage(msg); ...&#125; 线程本地变量那么如何根据不同的thread获取其自己的looper呢？这就要用到ThreadLocal了。ThreadLocal，顾名思义，就是线程的本地变量，他将变量和线程联系起来，是不同线程获取不同的值。其实这个实现很简单一点也不神秘，只是做了一些封装，用起来很方便，用在looper上（至于如何获取当前运行的线程，其实底部是通过native C语言方法来实现的） 12345678910 (Looper源码) ... static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); ... 想获取只需 sThreadLocal.get()(将本身ThreadLocal&lt;Looper&gt;作为map的键)Thread里面有一个map：ThreadLocal.ThreadLocalMap threadLocals 这样就可以实现线程间的通信了！而rxjava的各种操作符，asyncTask底部都是通过这个来实现的！另外就不得不提到kotlin的协程了 协程：就是一个线程框架，就是 Kotlin 提供的一套线程封装的 API——扔物线 kotlin的协成比rxjava等其他封装的更好，功能更强大，更方便，推荐大家去学习！","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"},{"name":"操作系统","slug":"操作系统","permalink":"https://messi-wpy.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://messi-wpy.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"线程","slug":"线程","permalink":"https://messi-wpy.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"Android超长图加载与subsampling scale image view实现分析","slug":"Android超长图加载与subsampling scale image view实现分析","date":"2019-08-09T16:00:00.000Z","updated":"2019-11-08T09:55:23.857Z","comments":true,"path":"2019/08/10/Android超长图加载与subsampling scale image view实现分析/","link":"","permalink":"https://messi-wpy.github.io/2019/08/10/Android%E8%B6%85%E9%95%BF%E5%9B%BE%E5%8A%A0%E8%BD%BD%E4%B8%8Esubsampling%20scale%20image%20view%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"Android中的图片加载一直是很重要的一块，也是很令人头疼的一块，动不动就出现OOM。所以我们有fresco等优秀的第三方框架，什么三级缓存，一行代码就帮我们轻松实现。但当面对超级长超级大分辨率尺寸的图时，就显得无能为力了，如果直接加载到内存中就又会出现OOM。 1.BitmapRegionDecoder实现长图大图的加载，最关键的类就是BitmapRegionDecoder他可以实现对图片的局部加载。 123456mDecoder=BitmapRegionDecoder.newInstance(image,false); //这里不能用option来获取图片的宽和高，因为经过BitmapRegionDecoder类处理过后的inputstream不能在获取的其信息，自动返回-1 imageHeight=mDecoder.getHeight(); imageWidth=mDecoder.getWidth(); bmp = mDecoder.decodeRegion(mRect, option); 这里注意经过BitmapRegionDecoder类处理过后的inputstream不能再用option获取其信息，会自动返回-1。当创建decoder对象后其实并没有将图片加载到内存中，只有调用了bmp = mDecoder.decodeRegion(mRect, option);之后才将这个mrect矩形的图片局部加载到内存中。 自己实现那么既然Android有这么方便的类，那我们岂不是很简单就可以自己实现啦！所以参考 鸿洋_的Android 高清加载巨图方案 拒绝压缩图片这篇博客，我们可以自己实现一个简易的加载长图框架： 自定义一个view，重写他的ondraw（）和onTouchEvent() 创建GestureDetector.OnGestureListener的实现类和scroller去接管触摸事件，在move时记录滑动距离，重写computeScroll()去辅助滑动 初始化我们的局部加载类BitmapRegionDecoder，当屏幕滑动到哪，记录其坐标到rect里然后直接mDecoder.decodeRegion(mRect, option);调用 invalidate()去ondraw（） 同时注意设置option.inBitmap开启图片的复用，进一步减少内存占用 另一个减小内存开销的就是设置合适的采样率，根据控件的大小对图片进行合适的采样压缩1234567int insamplesize=1;while (imageWidth&gt;1.6*width) &#123; imageWidth /= 2; insamplesize*=2;&#125;option.inMutable=true;option.inSampleSize=insamplesize; 12345678910protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mDecoder!=null) &#123; option.inBitmap=bmp; matrix.setScale(scale,scale); bmp = mDecoder.decodeRegion(mRect, option); canvas.drawBitmap(bmp,matrix,bitmapPaint); Log.i(&quot;TAG&quot;, &quot;onDraw: &quot;+bmp.getByteCount()); &#125; &#125; 注意：这里记录一个小小的坑：当用matrix进行图片的放大时，一定一定要设置画笔Paint，设置抗锯齿等优化，设与不设的差距真的挺大的123456private Paint bitmapPaint; bitmapPaint = new Paint(); bitmapPaint.setAntiAlias(true); bitmapPaint.setFilterBitmap(true); bitmapPaint.setDither(true); 结论这样一个简易的图片加载框架就实现了，完美的避免了OOM，因为不用把图片完整的加载到内存中！但是，经过实测，这种方法在加载分辨率比较小的大图时滑动还是挺丝滑的，但一遇到分辨率再大一点的，就会感受到明显的滑动的卡顿，于是我把目光转向了subsampling scale image view这个目前应该是最流行的开源框架 2.subsampling scale imag实现原理这里以原理实现为主，不想贴很多代码，具体可自己下载阅读github地址 1.ImageSourcesubsampling scale image view通过这个类ImageSource去获取图片，所以我们的图片资源都需要通过ImageSource去加载，支持从assets，文件，流中加载，从源码上看他其实就是一个工具类，用于方便加载各个路径的文件 2.fullImageSampleSize.fullImageSampleSamplSize由private int calculateInSampleSize(float scale)计算出，这个值应该是我们首先应该理解的。他决定了图片是否需要用BitmapRegionDecoder进行区域加载。如果他的计算结果等于1，则表示这张图的分辨率还不够大，不需要进行切割进行区域加载，所以这种情况下是最简单的，直接将图加载进入，放大缩小，移动，都是通过Matrix来实现的，所以接下来就来说一下Matrix 3.Matrixmatrix，矩阵，很多关于图片的功能都能通过他来做一些十分的变换来实现（可惜当年线代没学好。。。）比如图片我的位移，放缩，旋转等等。subsampling scale image view也用了matrix来实现图片的放缩和位移，主要方法是matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4); 有两个数组srA，rray和dstArraydstarray数组决定了图片在屏幕的位置，而大图的移动滑动就是通过他来实现的 4.Tileprivate static class Tile这个内部类就是切片类，subsampling scale image view中最重要的一个数据结构。 12345678910111213private static class Tile &#123; private Rect sRect; private int sampleSize; private Bitmap bitmap; private boolean loading; private boolean visible; // Volatile fields instantiated once then updated before use to reduce GC. private Rect vRect; private Rect fileSRect; &#125; 他的属性也很简单就是用来存储图片的一段切片信息，各种rect和bitmap和一个samplesiz其中需要区分一下各个rect srect和filesrect其实是保存这个切片的原始大小区域，也就调用是mDecoder.decodeRegion(mRect, option)区域加载时传入的rect vRect描述绘制在view画布中的实际位置，也就是说图片放大后的上下滑动就是通过改变这个rect结合matrix.setPolyToP()来实现的123456789101112131415 protected void onDraw(Canvas canvas) &#123; ...... if (matrix == null) &#123; matrix = new Matrix(); &#125; matrix.reset(); setMatrixArray(srcArray, 0, 0, tile.bitmap.getWidth(), 0, tile.bitmap.getWidth(), tile.bitmap.getHeight(), 0, tile.bitmap.getHeight()); if (getRequiredRotation() == ORIENTATION_0) &#123; setMatrixArray(dstArray, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, &#125;... ... matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4); canvas.drawBitmap(tile.bitmap, matrix, bitmapPaint); ......&#125; 5.三个taskTilesInitTask，TileLoadTask ，BitmapLoadTasksubsampling scale image view内部又创建了三个继承自AsyncTask的task用来在后台加载decode图从而不阻碍ui主线程，更加流畅。所以当fullImageSampleSize==1时，就直接用BitmapLoadTask解码整个图片不需切割，当期大于1时，就需要用TileLoadTask区域解码分割后的图片 Map&lt;Integer, List&lt;Tile&gt;&gt; tileMap最后介绍这个框架的核心，就是这个map我们知道，图片放得越大，所需要的像素分辨率就要越高才能匹配，要不然就会很模糊。相反，如果图片缩得很小，就不需要很高的分辨率，多了就浪费了。而Android中就可以根据 option.inSampleSize来对图片进行采样压缩，减小分辨率。所以，根据这个原理，subsampling scale image view将其根据需要计算出不同的采样率，当做key，然后根据不同的采样率进行切割，生成List&lt;Tile&gt;放大的时候，subsampling scale image view会选取合适的采样率后获取到List&lt;Tile&gt;然后进行解码，并且，他只会解码显示的部分，也就是til.visiable为true时才会解码。否者将其回收。 综上就是subsampling scale image view的大致实现原理 对比对比自己实现的和subsampling scale image view，后者在大图的切片方面做得更好只将大图切成若干片，在判断是否可见，如果可见就加载到内存中，否者回收；滑动时只改变矩阵的值进行简单的位移变换，进一步提升了流畅度，而且根据不同放缩比例选择合适的采样率，进一步减少内存占用。自己实现的每滑动一次就要重新解码绘制好几次，所以后者性能更高，值得学习。Android中的图片加载一直是很重要的一块，也是很令人头疼的一块，动不动就出现OOM。所以我们有fresco等优秀的第三方框架，什么三级缓存，一行代码就帮我们轻松实现。但当面对超级长超级大分辨率尺寸的图时，就显得无能为力了，如果直接加载到内存中就又会出现OOM。 1.BitmapRegionDecoder实现长图大图的加载，最关键的类就是BitmapRegionDecoder他可以实现对图片的局部加载。 123456mDecoder=BitmapRegionDecoder.newInstance(image,false); //这里不能用option来获取图片的宽和高，因为经过BitmapRegionDecoder类处理过后的inputstream不能在获取的其信息，自动返回-1 imageHeight=mDecoder.getHeight(); imageWidth=mDecoder.getWidth(); bmp = mDecoder.decodeRegion(mRect, option); 这里注意经过BitmapRegionDecoder类处理过后的inputstream不能再用option获取其信息，会自动返回-1。当创建decoder对象后其实并没有将图片加载到内存中，只有调用了bmp = mDecoder.decodeRegion(mRect, option);之后才将这个mrect矩形的图片局部加载到内存中。 自己实现那么既然Android有这么方便的类，那我们岂不是很简单就可以自己实现啦！所以参考 鸿洋_的Android 高清加载巨图方案 拒绝压缩图片这篇博客，我们可以自己实现一个简易的加载长图框架： 自定义一个view，重写他的ondraw（）和onTouchEvent() 创建GestureDetector.OnGestureListener的实现类和scroller去接管触摸事件，在move时记录滑动距离，重写computeScroll()去辅助滑动 初始化我们的局部加载类BitmapRegionDecoder，当屏幕滑动到哪，记录其坐标到rect里然后直接mDecoder.decodeRegion(mRect, option);调用 invalidate()去ondraw（） 同时注意设置option.inBitmap开启图片的复用，进一步减少内存占用 另一个减小内存开销的就是设置合适的采样率，根据控件的大小对图片进行合适的采样压缩1234567int insamplesize=1;while (imageWidth&gt;1.6*width) &#123; imageWidth /= 2; insamplesize*=2;&#125;option.inMutable=true;option.inSampleSize=insamplesize; 12345678910protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mDecoder!=null) &#123; option.inBitmap=bmp; matrix.setScale(scale,scale); bmp = mDecoder.decodeRegion(mRect, option); canvas.drawBitmap(bmp,matrix,bitmapPaint); Log.i(&quot;TAG&quot;, &quot;onDraw: &quot;+bmp.getByteCount()); &#125; &#125; 注意：这里记录一个小小的坑：当用matrix进行图片的放大时，一定一定要设置画笔Paint，设置抗锯齿等优化，设与不设的差距真的挺大的123456private Paint bitmapPaint; bitmapPaint = new Paint(); bitmapPaint.setAntiAlias(true); bitmapPaint.setFilterBitmap(true); bitmapPaint.setDither(true); 结论这样一个简易的图片加载框架就实现了，完美的避免了OOM，因为不用把图片完整的加载到内存中！但是，经过实测，这种方法在加载分辨率比较小的大图时滑动还是挺丝滑的，但一遇到分辨率再大一点的，就会感受到明显的滑动的卡顿，于是我把目光转向了subsampling scale image view这个目前应该是最流行的开源框架 2.subsampling scale imag实现原理这里以原理实现为主，不想贴很多代码，具体可自己下载阅读github地址 1.ImageSourcesubsampling scale image view通过这个类ImageSource去获取图片，所以我们的图片资源都需要通过ImageSource去加载，支持从assets，文件，流中加载，从源码上看他其实就是一个工具类，用于方便加载各个路径的文件 2.fullImageSampleSize.fullImageSampleSamplSize由private int calculateInSampleSize(float scale)计算出，这个值应该是我们首先应该理解的。他决定了图片是否需要用BitmapRegionDecoder进行区域加载。如果他的计算结果等于1，则表示这张图的分辨率还不够大，不需要进行切割进行区域加载，所以这种情况下是最简单的，直接将图加载进入，放大缩小，移动，都是通过Matrix来实现的，所以接下来就来说一下Matrix 3.Matrixmatrix，矩阵，很多关于图片的功能都能通过他来做一些十分的变换来实现（可惜当年线代没学好。。。）比如图片我的位移，放缩，旋转等等。subsampling scale image view也用了matrix来实现图片的放缩和位移，主要方法是matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4); 有两个数组srA，rray和dstArraydstarray数组决定了图片在屏幕的位置，而大图的移动滑动就是通过他来实现的 4.Tileprivate static class Tile这个内部类就是切片类，subsampling scale image view中最重要的一个数据结构。 12345678910111213private static class Tile &#123; private Rect sRect; private int sampleSize; private Bitmap bitmap; private boolean loading; private boolean visible; // Volatile fields instantiated once then updated before use to reduce GC. private Rect vRect; private Rect fileSRect; &#125; 他的属性也很简单就是用来存储图片的一段切片信息，各种rect和bitmap和一个samplesiz其中需要区分一下各个rect srect和filesrect其实是保存这个切片的原始大小区域，也就调用是mDecoder.decodeRegion(mRect, option)区域加载时传入的rect vRect描述绘制在view画布中的实际位置，也就是说图片放大后的上下滑动就是通过改变这个rect结合matrix.setPolyToP()来实现的123456789101112131415 protected void onDraw(Canvas canvas) &#123; ...... if (matrix == null) &#123; matrix = new Matrix(); &#125; matrix.reset(); setMatrixArray(srcArray, 0, 0, tile.bitmap.getWidth(), 0, tile.bitmap.getWidth(), tile.bitmap.getHeight(), 0, tile.bitmap.getHeight()); if (getRequiredRotation() == ORIENTATION_0) &#123; setMatrixArray(dstArray, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, &#125;... ... matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4); canvas.drawBitmap(tile.bitmap, matrix, bitmapPaint); ......&#125; 5.三个taskTilesInitTask，TileLoadTask ，BitmapLoadTasksubsampling scale image view内部又创建了三个继承自AsyncTask的task用来在后台加载decode图从而不阻碍ui主线程，更加流畅。所以当fullImageSampleSize==1时，就直接用BitmapLoadTask解码整个图片不需切割，当期大于1时，就需要用TileLoadTask区域解码分割后的图片 Map&lt;Integer, List&lt;Tile&gt;&gt; tileMap最后介绍这个框架的核心，就是这个map我们知道，图片放得越大，所需要的像素分辨率就要越高才能匹配，要不然就会很模糊。相反，如果图片缩得很小，就不需要很高的分辨率，多了就浪费了。而Android中就可以根据 option.inSampleSize来对图片进行采样压缩，减小分辨率。所以，根据这个原理，subsampling scale image view将其根据需要计算出不同的采样率，当做key，然后根据不同的采样率进行切割，生成List&lt;Tile&gt;放大的时候，subsampling scale image view会选取合适的采样率后获取到List&lt;Tile&gt;然后进行解码，并且，他只会解码显示的部分，也就是til.visiable为true时才会解码。否者将其回收。 综上就是subsampling scale image view的大致实现原理 对比对比自己实现的和subsampling scale image view，后者在大图的切片方面做得更好只将大图切成若干片，在判断是否可见，如果可见就加载到内存中，否者回收；滑动时只改变矩阵的值进行简单的位移变换，进一步提升了流畅度，而且根据不同放缩比例选择合适的采样率，进一步减少内存占用。自己实现的每滑动一次就要重新解码绘制好几次，所以后者性能更高，值得学习。","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/tags/Android/"},{"name":"图片加载","slug":"图片加载","permalink":"https://messi-wpy.github.io/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"}]},{"title":"Android 网络请求心得","slug":"Android网络请求","date":"2019-05-13T16:00:00.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2019/05/14/Android网络请求/","link":"","permalink":"https://messi-wpy.github.io/2019/05/14/Android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/","excerpt":"","text":"Rxjava+retrofit+okhttp的网络请求框架之需要注意的地方 1 retrofit和okhttp异步回调的线程问题： okhttp异步调用后，callback运行在子线程 retrofit异步调用后，其callback运行在主线程，retrofit就是对okhttp的一系列封装，运用了大量设计模式，其回调结果最后通过handle传到了主线程，这点要注意，尤其在更新ui时 rxjava封装后，回调线程可以通过其线程调度来很方便的设置 2 rxjava 的Observable封装的 retrofit call的泛型参数： TypeBody(class类)：如 123456789public class Result&#123; private String name; private String ID;&#125;//在相应retrofit接口中@GET(.....)Observable&lt;Result&gt; Login() 通过添加gson转换器，将网络请求响应中返回的json转换为相应的java类，方便操作，注意这个必须在创建retrofit是添加gson转换器.addConverterFactory(GsonConverterFactory.create()) ResponseBody(okhttp包下的) 12@GET(...)Observable&lt;ResponseBody&gt; Login() 这个适用于你不需要将其转换成具体的类，只是想获取响应体，当让你也可以获取body后自己手动解析body数据 Response&lt;T&gt;(retrofit包下)这个将所有响应结果都封装到了这个response里，他的泛型参数可以填ResponseBody或者class类，通过他不仅可以获取body，还可以获取响应码等。 3 Rxjava的网络请求错误处理 注意,如果是用Response包裹的响应体，那么之前说过，所有东西都被包裹在了Response里，所以即使是错误的响应，如4××/5××,也会包裹在Response里，发送给onNext(),而不会发送给onError(),而错误的响应体可以通过123if (e instanceof HttpException)&#123; (HttpException)e).response().errorBody() &#125; 获取错误的响应体。而如果不是用Response包裹，那么除了2**的响应吗会进入onNext()里，其他的响应码都会直接进入onError()里,这样就中断了这个观察链 参考stackoverfollow 关于rxjava的flatmap链式调用：flatmap可以解决回调地狱，解决连续进行网络请求的问题，如123456789101112131415161718192021222324252627282930313233343536373839Observable.just(&quot;hello&quot;) .flatMap(new Func1&lt;String, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(String s) &#123; Log.i(TAG, &quot;call: flatmap -----1&quot;); s = &quot;hellp flapmap1&quot;; if (s != null) return Observable.error(new NullPointerException(&quot;null test&quot;)); return Observable.just(s); &#125; &#125;).flatMap(new Func1&lt;Object, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(Object o) &#123; Log.i(TAG, &quot;call: flatmap-----2&quot;); return Observable.just(&quot;33333&quot;); &#125; &#125;).subscribe(new Subscriber&lt;Object&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, &quot;onCompleted: &quot;); &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, &quot;onError: call&quot;); if (e instanceof NullPointerException) Log.i(TAG, &quot;onError: illegal &quot; + e.getMessage()); &#125; @Override public void onNext(Object o) &#123; Log.i(TAG, &quot;onNext: &quot;); &#125; &#125;); 第一个flatmap中抛出了一个异常，那么下一个flatmap就不会调用，直接进入了最后订阅的观察者中，进入onError()里。可见，即便你在flatmap里对上一个被观察者发送的结果进行了操作，但他并不算是一个观察者，只是对其进行了一部分处理，map等操作符也是这样，他们共同组成了一个长长的链，唯一的观察者在最后订阅的Subscriber中处理，所以如果中间任意环节出了异常，那么该链在此中断，直接进入最后观察者的onerror里。所以之前的如果用Response包裹，就不会中断观察链，你可以根据响应码做一些处理。 4 okhttp的拦截器及重定向处理 okhttp的拦截器是其责任链模式的重要实现，通过一个个拦截器将网络链接的各个部分，模块拆分开，分工明确 okhttp中对重定向的处理是通过其第一个内置的拦截器RetryAndFollowUpInterceptor实现的，他通过while循环来不断创建request请求资源，知道响应码为200（或错误），当然他也负责进行失败重试 关于Application interceptors与Network Interceptors区别他们其实都是用户自定义的拦截器，只是添加顺序不同，导致有区别 okhttp源码中的添加顺序：可见Application interceptors第一个添加，而Network Interceptors添加在RetryAndFollowUpInterceptor等拦截器之后，所以Network Interceptors可以拦截到重定向的请求，而Application interceptors只能拦截到刚开始的请求和最后重定向后的结果 参考：博客","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"},{"name":"网络请求","slug":"网络请求","permalink":"https://messi-wpy.github.io/categories/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"}],"tags":[{"name":"网络请求","slug":"网络请求","permalink":"https://messi-wpy.github.io/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/tags/Android/"}]},{"title":"Android FragmentManager使用","slug":"AndroidFragment学习","date":"2019-04-24T16:00:00.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2019/04/25/AndroidFragment学习/","link":"","permalink":"https://messi-wpy.github.io/2019/04/25/AndroidFragment%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Android FragmentManager使用1.获取fragmentManager要想使用好fragmentmanager，第一步肯定先要正确获取他呀： 获取activity中的fragmentmanager：在activity中 getFragmentManager()或getSupportFragmentManager()（这个用于support包的fragment，向下兼容，现api28后变成support包全部转为Androidx）如果在fragment中则可以先getactivity（）获取到其依赖的activity 获取在fragment中的fragmentmanager：getChildFragmentManager()这种情况用于fragment中嵌套fragment，同时子fragment可以通过getParentFragment()获得 2.事务 在Android中fragmentManager是以事务为单位来管理的，每次我们都通过fragmentManager.beginTransaction()来获得一个FragmentTransaction对象，然后进行添加，替换，删除等，最后commit提交，这整个过程从begin到commit进行的所有操作就是一个事务，每个commit提交一个事务 这里要注意commit调用commit()方法并不立即执行这个事务，而是在Activity的UI线程之上（”main”线程）调度运行，以便这个线程能够尽快执行这个事务，这意味这个commit是异步的，所以必要时可以通过commitNow()来立即执行 2.fragmentManager的各种方法 add()add方法会直接将一个fragment添加到指定的id布局中，不管这个布局容器中原来有没有，无条件覆盖。所以会叠加，而之前的fragment只是被遮挡，view并不会被摧毁 getFragmentbyTag()与getFragmentbyId()这两个方法可以获得有相应的tag或id属性的fragment（这两个属性也可以通过xml里布局设置），那么就出现了有多个fragment拥有相同的tag和id，那调用该方法获得的是哪个呢？实测获得的是最顶层的那个fragment，也就是最近添加的 replace()该方法不同于add()可有其注释的出，relplace()会先相应调用该布局id容器中中所有的add的fragment的remove()方法，然后在调用add()方法 remove()移除这个fragment，最后会调用onDetach() show()和hide() ,这里要注意调用这两个方法并不会走fragment的生命周期，which means 并不会调用onPause（），onStop方法，而是只调用了onHiddenChanged()方法，所有改变应在这个方法里，重写之 addToBackTrack()最后说一下fragment的回退栈，注意，只有在commit事务是调用了addToBackTrack()方法，才会有回退栈，才会在回退栈里添加，否则就没有回退栈，pop方法不会有任何改变。 addToBackTrack()即把本次事务的所有操作储存起来，注意调用了addtobaktrack后remove方法不会真的把fragment移除，而只是distroy了它的view，并没有调用onDetach(),也就是说它还连接在宿主中。 popbackTrack，该方法即将回退栈中的最近的一次事务pop出来，也就是反过来调用方法，add就是remove，remove就add，所以如果这个调用了replace，那么pop后就会将这个replace add的fragment移除，然后在把之前remove的所有fragment add到里面。而之前就存在的fragment依然存在，没有变化，就像是add覆盖到上面一样。所以加入回退栈后pop可以回到上次操作 最后，fragment在现在开发中已经十分常用，所以必须完全理解他的生命周期和fragmentManager如何管理它，这样才能高效的复用，利用fragment","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"}],"tags":[{"name":"fragment","slug":"fragment","permalink":"https://messi-wpy.github.io/tags/fragment/"}]},{"title":"Android JetPack 架构","slug":"Android JetPack 架构","date":"2019-04-07T16:00:00.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2019/04/08/Android JetPack 架构/","link":"","permalink":"https://messi-wpy.github.io/2019/04/08/Android%20JetPack%20%E6%9E%B6%E6%9E%84/","excerpt":"","text":"Android JetPack 架构Androidx 包数据绑定 bulid.gradle123456android &#123;...dataBinding &#123; enabled = true &#125;&#125; 绑定变量：可以创建数据类，集合，导入其他类 方法如onclick()","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"},{"name":"JetPack","slug":"JetPack","permalink":"https://messi-wpy.github.io/categories/JetPack/"}],"tags":[{"name":"JetPack","slug":"JetPack","permalink":"https://messi-wpy.github.io/tags/JetPack/"}]},{"title":"Android构建工具各种版本","slug":"android gradle plugin中各种版本","date":"2019-03-18T01:24:25.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2019/03/18/android gradle plugin中各种版本/","link":"","permalink":"https://messi-wpy.github.io/2019/03/18/android%20gradle%20plugin%E4%B8%AD%E5%90%84%E7%A7%8D%E7%89%88%E6%9C%AC/","excerpt":"","text":"Android构建工具各种版本minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersionminSdkversion: 作用：告诉应用市场安装该应用的最低版本 compilesdkversion： 作用：告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。targetsdkversion 作用：主要是为了Android系统的向前兼容，targetSdkVersion 所暗示的许多行为变化都记录在 VERSION_CODES 文档中，所以当出现更新了新系统时，如果新系统版本大于了该应用的targetsdkversion版本，就不会在该应用使用最新的变化， targetSdkVersion 是 Android 提供向前兼容的主要依据，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的行为变化 buildtoolversion-作用：表示构建工具的版本，其中包括了打包工具aapt、dx等等，所以应该大于compile版本","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://messi-wpy.github.io/categories/Gradle/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://messi-wpy.github.io/tags/Gradle/"}]},{"title":"正则表达式（Java）","slug":"正则表达式","date":"2019-03-18T01:24:25.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2019/03/18/正则表达式/","link":"","permalink":"https://messi-wpy.github.io/2019/03/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式（Java） JAVA中的反斜杠 \\:注意： 在java中反斜杠 \\ 本身具有特殊含义，表转义字符，所以要想打出 \\ 就需要\\\\(很多语言都是这样)所以，作为转义字符，有\\n表换行 …要想输入\\,就需要\\\\, System.out.print(&quot;\\\\&quot;)—–&gt; \\ 常用的正则表达符号 . 匹配所有单个字符 \\ 反斜杠，将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\\n”匹配换行符。序列”\\\\“匹配”\\“，”\\(“匹配”(“ ^ $分别表示从开始位置匹配和结尾位置匹配 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo” +一次或多次匹配前面的字符或子表达式 ?零或一次匹配前面～～ {n}表示正好匹配n次，{n,}表示至少匹配n次，{n,m}表示匹配 &gt;=n,&lt;=m (regex):括号表示捕获所匹配的字符串 [xyz]：方括号表示字符集，匹配匹配包含的任一字符[^xyz]反向字符集 [a-z] 表示所有小写字母 \\b匹配一个字边界，即字与空格间的位置，如”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\d表示数字，等效[0-9] \\D非数字 \\s匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。S非空格 \\w匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 Pattern 与Matcher类使用；pattern 用其静态方法compile(regex) 创建，有split等方法matcher可以用pattern.matcher(String)来创建，有matches相关，捕获方法注意 find()方法是部分匹配，是查找输入串中与模式匹配的子串，如果该匹配的串有组还可以使用group()函数。 matches()是全部匹配，是将整个输入串与模式匹配，如果要验证一个输入的数据是否为数字类型或其他类型，一般要用matches()。 必须先match.find(),然后才会捕获匹配，然后match.group()获取find结果，可以while(match.find())来一直搜索所有匹配到的 分组 从正则表达式左侧开始，每出现一个左括号“(”记做一个分组，分组编号从1开始。0代表整个表达式。 主要用于matcher.find(),,, matcher.group(index)group(0)特指所匹配到的整个字符串，不计入group的length","categories":[{"name":"Java","slug":"Java","permalink":"https://messi-wpy.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://messi-wpy.github.io/tags/Java/"}]},{"title":"android 中图片单位及图片加载优化相关知识","slug":"android图片加载相关","date":"2019-03-15T01:24:25.000Z","updated":"2019-11-16T10:27:11.091Z","comments":true,"path":"2019/03/15/android图片加载相关/","link":"","permalink":"https://messi-wpy.github.io/2019/03/15/android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%85%B3/","excerpt":"","text":"android 中图片单位及图片加载优化相关知识 1. 图片相关知识，像素，分辨率px就是图片中最小的点，最小单位，单位色块,每个图都是由这些小像素点组成的，如基本的图片格式bitmap,注意像素的大小没有固定的长度，不同设备上一个单位的像素色块的大小是不一样的 分辨率=画面水平方向的像素值 * 画面垂直方向的像素值。 分辨率可以分为两方面：屏幕分辨率和图像分辨率。 屏幕分辨率如1024*768,就表示设备水平方向上有1024个像素点，垂直方向上有768个 图片分辨率也如上所说，比如如果某图片是500*200,就表示如果这个图片一比一显示的话，就是水平方向有500个像素点，而垂直方向有200个. 而像素点的大小不一样，所以同一张分辨率的图片在不同尺寸的显示器上很可能显示不同大小，或者即便尺寸相同，分辨率高的那个图片显示会小 像素越高，单个面积越小，显示的画质就越细致（当然要有相应分辨率的图片） 补充：图片的放大缩小： 放大是通过算法认为插入很多像素，所以如果放的很大，有效像素就很少，就会变得模糊 缩小是通过一定的算法删去一部分像素，所以会在细节上对视一小部分像素 所以如果图像分辨率小于显示器分辨率时，第一种是显示实际大小，但不是全屏，第二种是放大来全屏显示 如果大于显示器分辨率，第一种是局部显示（全屏），可拖放，第二种是通过缩小全屏显示 finally,虽然不同设备上像素块大小会不一样，但是同一台硬件设备上的屏幕分辨率、像素块大小是不会变的。PC电脑上之所以可以调整屏幕分辨率，其实也是通过算法转换了1.android 图片，控件大小相关单位 px:(Pixel像素)构成图像的基本单元，但是单个像素的大小不固定，所以在不同尺寸设备上会有拉伸缩放，不推荐 dpi:是指屏幕上每英寸距离中有多少个像素点，dpi=dpi=√hight^2+width^2 / size (android以160dpi为标准) dp(dip) 设备独立像素 device independent pixel一般都用这个作单位，顾名思义，独立，对于相同尺寸的手机，即使分辨率不同，同DP的组件占用屏幕比例相同，UI效果也相同。（注意，是相同的尺寸） dp可以维护Android组件自身的比例平衡，不至于在不同屏幕上变形转换公式：px = dp * (dpi/160) sp 主要用于字体，使得字体可以根据用户手机设置来修改字体大小 注:如今的dpi不能根据物理计算，是厂家生产时写在系统配置中的固定数值，为了简化屏幕适配，一般机型的dpi的取值会参考上面的范围，但是总会有一些特殊的机型就是不采纳官方的建议可通过：dpi可以通过DisplayMetrics类的densityDpi属性获取当前手机的dpi数值，该类也可以获取到跟屏幕密度有关的其它属性。一般获取DisplayMetrics类有以下方法： 12345678方式1://content:Activity,Content,Application. DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics();方式2://getSystemService可以通过 Activity,Content,Application等获取. DisplayMetrics displayMetrics = new DisplayMetrics(); WindowManager windowManager = (WindowManager)getSystemService(Context.WINDOW_SERVICE); windowManager.getDefaultDisplay().getMetrics(displayMetrics); 屏幕适配主流推荐今日头条适配方案但自己不是太懂。。。 使用wrap_content、match_parent、weight 使用相对布局 几个不同文件夹放的本地图片drawable Bitmap.decodeResource() 源码，新图的高度 = 原图高度 * (设备的 dpi / 目录对应的 dpi ) bitmapBitmap 就是Android中的图片，一张位图，只有生成了bitmap,才占内存，可以通过bitmap.getbytecount()来获取该bitmap具体占用内存 bitmap的创建： 通过已有的bitmap创建（可以对已有的bitmap进行各种操作放大，裁剪等）：createBitmap(...)createScaleBitmap(...)… 通过BitmapFactory，从各种数据源来解析，创建bitma对象： decodeByteArray(byte[] data, int offset, int length)：从指定的字节数组的offset位置开始，将长度为length的字节数据解析成Bitmap对象。 decodeFile(String pathName)：从pathName指定的文件中解析、创建Bitmap对象。 decodeFileDescriptor(FileDescriptor fd)：从FileDescriptor对应的文件中解析、创建Bitmap对象。 decodeResource(Resources res, int id)：根据给定的资源ID从指定资源中解析、创建Bitmap对象。 decodeStream(InputStream is)：从指定的输入流中解析、创建Bitmap对象。 BitmapFactory.Options BitmapFactory.Options类是BitmapFactory对图片进行解码时使用的一个配置参数类，其中定义了一系列的public成员变量，每个成员变量代表一个配置参数。 inperferredConfig参数,设置图片使用的颜色模式 inJustDecodeBounds，true—&gt;告诉BitmapFactory只是获得长宽，不用加载bitmap到内存中，返回null inSmapleSize 尺寸压缩，减少图片水平竖直像素点（分辨率）只能缩小，且为2的倍数，（&lt;1时自动变为1） Matrix matrix类，即矩阵，可以对图片bitmap矩阵进行一些列线性变换，放大，旋转，位移等等 图片的三层缓存加载图片时，应一次从内存—&gt;本地—&gt;网络去寻找图片资源，并以图片的url值为key 从内存获取：使用的是LruCache这个类（Least Recently Used ）即最近最少使用算法，内部维护一个LinkedHashMap 从文件获取：google推荐的DiskLruCache，硬盘缓存类 网络 在上传，缓存本地时最好压缩一下，insamplesize尺寸压缩和compress质量压缩，以减小文件大小 加载网络大图，多图优化加载大图，长图时，可以用BitmapRegionDecoder进行图片的局部加载 参考：google-androldcsdn1zhihu","categories":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://messi-wpy.github.io/tags/Android/"},{"name":"图片加载","slug":"图片加载","permalink":"https://messi-wpy.github.io/tags/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"}]},{"title":"c++坑之拷贝函数总结","slug":"c++坑之构造函数","date":"2018-12-16T15:35:46.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2018/12/16/c++坑之构造函数/","link":"","permalink":"https://messi-wpy.github.io/2018/12/16/c++%E5%9D%91%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","excerpt":"","text":"C++构造函数 c++类的中有两个特殊的构造函数(都是构造函数)(1)无参构造函数 (2)拷贝构造函数classname (const classname &amp;obj)（默认的拷贝构造函数—常引用型，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量） 它们的特殊之处在于：(1)当类中没有定义任何构造函数时，编译器会默认提供一个无参构造函数且其函数体为空；(2)当类中没有定义拷贝构造函数时，编译器会默认提供一个拷贝构造函数，进行成员变量之间的拷贝。(这个拷贝操作是浅拷贝) 注意：也就是说,构造函数包含拷贝函数，如果定义了一个拷贝函数，就没有默认的构造函数了 拷贝函数的使用时机当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数： 一个对象以值传递的方式传入函数体 一个对象以值传递的方式从函数返回 一个对象需要通过另外一个对象进行初始化 c++STL容器也是调用拷贝构造函数 深拷贝和浅拷贝1.深拷贝是为指针分配了地址(比如为其new了一个新的)而浅拷贝只是赋值－－－pr1=pr2,此时浅拷贝两个的对象的某个属性的指针指向同一块地址。(图：浅拷贝，深拷贝) 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝 等号运算符与拷贝函数1234567如果对象在申明的同时马上进行的初始化操作，则称之为拷贝运算。例如： class1 A(&quot;af&quot;); class1 B=A; 此时其实际调用的是B(A)这样的浅拷贝操作。如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如： class1 A(&quot;af&quot;); class1 B; B=A; 此时实际调用的类的缺省赋值函数B.operator=(A); 等号运算符类似浅拷贝，所以，class有指针，不仅一定要重写拷贝构造函数（写深拷贝），还要重载=运算符８ ##NOTE 尽量避免值传递，最好用指针和引用.如果对象有内部指针指向动态分配的堆内存，丝毫不要考虑把对象按值传递给函数，要按引用传递。并记住：若函数不能改变参数对象的状态和目标对象的状态，则要使用const修饰符 对于类的成员需要动态申请堆空间的类的对象，大家都知道，我们都最好要overload其赋值函数和拷贝函数。拷贝构造函数是没有任何返回类型的，这点毋庸置疑。 而赋值函数可以返回多种类型，例如以上讲的void,类本身class1，以及类的引用 class &amp; (可以实现连等) 参考两篇很好的博客，博客２","categories":[{"name":"c++","slug":"c","permalink":"https://messi-wpy.github.io/categories/c/"}],"tags":[]},{"title":"gradle","slug":"gradle","date":"2018-11-19T09:14:00.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2018/11/19/gradle/","link":"","permalink":"https://messi-wpy.github.io/2018/11/19/gradle/","excerpt":"常用的Gradle命令","text":"常用的Gradle命令 查看版本号: gradle -v 编译执行某个task: gradle Task名 静默编译执行某个task: gradle -q Task名（q表示quiet模式，表示编译执行Gradle脚本的过程中，只输出必要的信息. 除了quiet模式外，Gradle中还有其他三种模式） 编译执行某个Project中的某个task：gradle -b Project名 Task名（Gradle默认只执行- - - build.gradle文件中，自定义其他文件xxx.gradle编译运行显式指定Project名称，这里的build.gradle其实表示的就是build Project） 显示所有的Project：gradle projects 显示所有的task：gradle tasks 显示gradle的gui：gradle –gui 或 gradle –gui&amp;（后台运行） 查找所有的gradle命令: gradle –help groovy与gradlegradle语法理解闭包（Closure）：就是一个代码块，可以看成一个对象一个类型，就像 int ,string 一样 特性 函数调用可以不用括号groovy中定义的函数，如果至少有一个参数，在调用的时候可以省略括号,如compileSdkVersion rootProject.ext.compileSdkVersion就等于 compileSdkVersion(...) 默认对象即该project(project就是这个gradle的工作),所以没有指明的变量方法都是这个project的,比如编译java,打包android , The first line in the build configuration applies the Android plugin forGradle to this build and makes the android {} block available to specifyAndroid-specific build options. apply plugin: &#39;com.android.application&#39;所以不同的project有不同的方法和任务。 变量引用 “$value “(via $ ) 闭包 Closure 可以改变上下文的代码块外的变量，很神奇的魔法，类比java 的lambda,匿名内部类","categories":[{"name":"Gradle","slug":"Gradle","permalink":"https://messi-wpy.github.io/categories/Gradle/"},{"name":"开发工具","slug":"开发工具","permalink":"https://messi-wpy.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://messi-wpy.github.io/tags/Gradle/"}]},{"title":"了解 Linux + Zsh + GCC + GDB + Vim/Emacs 环境","slug":"了解-Linux-Zsh-GCC-GDB-Vim-Emacs-环境","date":"2018-11-14T01:24:25.000Z","updated":"2019-11-08T09:13:00.528Z","comments":true,"path":"2018/11/14/了解-Linux-Zsh-GCC-GDB-Vim-Emacs-环境/","link":"","permalink":"https://messi-wpy.github.io/2018/11/14/%E4%BA%86%E8%A7%A3-Linux-Zsh-GCC-GDB-Vim-Emacs-%E7%8E%AF%E5%A2%83/","excerpt":"1.Linux为什么我们要用或必须用linux???！！！ free software不仅是因为他是免费的，他更是开源的，是真正自由的你知道自己到底要做什么，想怎么做，不需要有人来强制你安装一些东西，完全控制你的电脑，甚至是私人订制，DIY你的电脑 我觉得linux对我们来说，最重要的就是安装一些软件十分方便，配置环境更是几行命令的事，他带了很多高效的工具，比如git,vim,gdb等等，可以在终端（写一写shell脚本）实现一切操作…可能你们现在没太感觉到，但等你熟练以后，一定会发现他的好处的！而且，这个系统上没有游戏，等一些乱七八糟的软件，这会一定程度上阻止你开小差。。。所以，总的来说，linux真的是一个十分高效的，更适合程序员的操作系统。还有一个重要原因是，我们软件工程师，开发环境就是linux，当年Ｃ语言就是和Unix一起被发明出来的，后面所有的东西也都是unix为基础的 再退一步说，，，windows是什么？是比尔当年为了让他的老妈那样一点也不懂计算机的人使用而发明的。所以很多人也说GUI是万恶之源，，，windows从他的诞生，就注定被程序员鄙视，，，大家想想，用windows是不是大多数时间都是在玩游戏娱乐上,所以推荐大家，无论如何都要用上linux，投入开源大家庭","text":"1.Linux为什么我们要用或必须用linux???！！！ free software不仅是因为他是免费的，他更是开源的，是真正自由的你知道自己到底要做什么，想怎么做，不需要有人来强制你安装一些东西，完全控制你的电脑，甚至是私人订制，DIY你的电脑 我觉得linux对我们来说，最重要的就是安装一些软件十分方便，配置环境更是几行命令的事，他带了很多高效的工具，比如git,vim,gdb等等，可以在终端（写一写shell脚本）实现一切操作…可能你们现在没太感觉到，但等你熟练以后，一定会发现他的好处的！而且，这个系统上没有游戏，等一些乱七八糟的软件，这会一定程度上阻止你开小差。。。所以，总的来说，linux真的是一个十分高效的，更适合程序员的操作系统。还有一个重要原因是，我们软件工程师，开发环境就是linux，当年Ｃ语言就是和Unix一起被发明出来的，后面所有的东西也都是unix为基础的 再退一步说，，，windows是什么？是比尔当年为了让他的老妈那样一点也不懂计算机的人使用而发明的。所以很多人也说GUI是万恶之源，，，windows从他的诞生，就注定被程序员鄙视，，，大家想想，用windows是不是大多数时间都是在玩游戏娱乐上,所以推荐大家，无论如何都要用上linux，投入开源大家庭 ２．什么是终端，bash,shell, 控制台(console) shell、控制台、终端的区别 shell(有bash,zsh…等等) 就是命令行解释器,实现用户与linux内核交互这里推荐大家使用zsh,可以用oh-my-zsh快速安装zsh终端 更具体说是虚拟终端 3.c语言的编译gcc 编译过程 gcc hello.c —-&gt; 预处理(Preprocessing)-&gt; 编译(Compilation)-&gt;汇编(Assemble)-&gt;链接(Linking)预处理－－预处理用于将所有的#include头文件以及宏定义替换成其真正的内容编译－－生成汇编代码汇编－－将汇编代码生成二进制目标文件链接－－将各个目标文件链接起来，形成.out可执行文件 gcc命令使用 c语言各个编译过程详解 gdb调试 必须掌握 拒绝10 printf 例如文件：hello.c(用-o了来指定输出的文件名字) gcc -g hello.c -o hello — 注意用gdb 调试，必须使用GCC编译的 （其实是用GNU的编译器编译程序，c语言是gcc） 2.gdb hello进入调试 3.常用命令 run (r) 开始运行 break (b) 设置断点，break main(函数名)/5(num在当前文件的第五行)/hello.c:5(Break at line 5 of hello.c)clear/delete清楚，删除谋个断点display/undisplay展示谋个值，变量，每次运行时都进行展试print只是这次展示一次某一个值watch监视某个值，每次发生变化都会展示rwatch定一个变量，如果这个变量被读，则暂停程序运行，在调试器中显示信息，并等待下一个调试命令。list展示一段代码next单步执行 (在停止之后); 跳过函数调用step单步执行 (在停止之后); 进入函数调用continue 继续运行程序 (在停止之后，比如在一个断点之后)运行到下一个断点set设置变量的值。例如：set nval=54 将把54保存到nval变量中 4.w文本编辑器vi/vim(vi是vim老版本)1.vim的三种模式：命令模式（Command mode），输入模式（Insert mode）和 底线命令模式基本操作进阶操作","categories":[{"name":"介绍","slug":"介绍","permalink":"https://messi-wpy.github.io/categories/%E4%BB%8B%E7%BB%8D/"},{"name":"linux","slug":"linux","permalink":"https://messi-wpy.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://messi-wpy.github.io/tags/linux/"}]},{"title":"博客学习","slug":"博客学习","date":"2018-11-14T01:18:52.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2018/11/14/博客学习/","link":"","permalink":"https://messi-wpy.github.io/2018/11/14/%E5%8D%9A%E5%AE%A2%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"This is my “fucking” house and life","categories":[{"name":"介绍","slug":"介绍","permalink":"https://messi-wpy.github.io/categories/%E4%BB%8B%E7%BB%8D/"}],"tags":[]},{"title":"Machine Learning","slug":"Machine Learning","date":"2018-09-13T16:00:00.000Z","updated":"2019-11-08T09:15:45.360Z","comments":true,"path":"2018/09/14/Machine Learning/","link":"","permalink":"https://messi-wpy.github.io/2018/09/14/Machine%20Learning/","excerpt":"课程－－－吴恩达老师学习路线本来准备边看视频边看周志华大佬的西瓜书，结果第三章看完就给跪了，全是数学公式，总之，在没有把数学基础打好之前还是先别看这本书了（数学学习参考上面的学习路线，主要是微积分，概统，线性代数矩阵）否则完全看不懂的．．．相反视频里的是相对简单的，还有专门介绍线性代数的课程可以先看这个入门，然后再继续西瓜书","text":"课程－－－吴恩达老师学习路线本来准备边看视频边看周志华大佬的西瓜书，结果第三章看完就给跪了，全是数学公式，总之，在没有把数学基础打好之前还是先别看这本书了（数学学习参考上面的学习路线，主要是微积分，概统，线性代数矩阵）否则完全看不懂的．．．相反视频里的是相对简单的，还有专门介绍线性代数的课程可以先看这个入门，然后再继续西瓜书 第一周课程内容 基础名词 回归与分类 监督与不监督学习 我们的目标是，在给定训练集的情况下，学习函数h：X→Y，使得h（x）是y的对应值的“好”预测器 假设函数 方法线性回归1.cost function使用代价函数来衡量假设函数的准确性房价预测（线性回归问题）：choose i0,i1 so that h(x)is close to y for our training examples(x,y)mini 目标：假设函数的斜率和截距 更符合样本代价函数：－－－计算样本与计算的差距 J(i0,i1)= 1/2m∑(h(xi)-yi)^2－－平法差代价函数 2.梯度下降－－计算 cost function－－min j(i0,i1);不断递归计算，到函数收敛３．正规方程 多特征的线性回归 代价函数，参数梯度下降的变化，（偏导数） 特征缩放 线性回归 逻辑回归 减小过拟合 过拟合，表示由于features太多，虽然cost function趋近于零，但是对于新的数据的预测并不好（可能很好的拟合了实验数据） 欠拟合：表示模型不是一条直线，但却训练成了一条直线（比如），所以不能很喝的预测数据 减小过拟合： 减少选择的特征 正则化－－－在代价函数中“惩罚”某些参数，在cost function后加上theta,减小每个theta这样可以使其跟光滑，减小过拟合 如果正则化参数lambda过大时（惩罚过大，会造成欠拟合） 向量化减少迭代（for循环）－－－将其向量化代替 神经网络training set(x,y)—&gt;h(x)==y(约等)","categories":[{"name":"AI","slug":"AI","permalink":"https://messi-wpy.github.io/categories/AI/"}],"tags":[{"name":"j机器学习","slug":"j机器学习","permalink":"https://messi-wpy.github.io/tags/j%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"git命令总结","slug":"git命令总结","date":"2018-08-23T15:35:46.000Z","updated":"2019-11-08T09:13:36.527Z","comments":true,"path":"2018/08/23/git命令总结/","link":"","permalink":"https://messi-wpy.github.io/2018/08/23/git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","excerpt":"Linus Torvalds —— Just For Fun","text":"Linus Torvalds —— Just For Fun HEAD头指针 1.获取帮助 git help git –help2.建立仓库（工作平台） git init git add &lt;文件名&gt;( 跟踪该文件)（添加到暂存区） git commit -m“ ….”（添加到git仓库）git commit 不加参数则直接打开vim编译与.gitignore格式相同，+’-m’则直接在命令行中输入提交信息如果＋ “ -a”参数则可以跳过add 直接一步操作，跳过使用暂存区如 git commit -a -m”跳过暂存区” git push [远程仓库名] [远程分支]3. git 别名 如 git config –global alias.ci commit ,这输入 git commit 时只需要 git ci4.查看状态 git status git diff查看工作区与已暂存的文件的区别，更新了哪些，也就是修改之后还没有暂存起来的变化内容 git log (-p查看不同，-num 查看最近几次 -3,-2) git reflog 来查看引用日志 git remote show origin(查看origin仓库的更多信息，分支跟踪等信息) git show [commit id]－－查看某次提交修改了什么 5. .gitignore • 所有空行或者以 # 开头的行都会被 Git 忽略。• 可以使用标准的 glob 模式匹配。• 匹配模式可以以(/)开头防止递归。• 匹配模式可以以(/)结尾指定目录。• 要忽略指定模式以外的文件或目录,可以在模式前加上惊叹号(!)取反。 所谓的glob 模式是指 shell 所使用的简化了的正则表达式。星号()匹配零个或多个任意字符;[abc] 匹配任何一个列在方括号中的字符(这个例子要么匹配一个 a,要么匹配一个 b,要么匹配一个 c);问号(?)只匹配一个任意字符;如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配(比如[0-9] 表示匹配所有 0 到 9 的数字)。使用两个星号() 表示匹配任意中间目录,比如a/**/z 可以匹配 a/z,a/b/z 或 a/b/c/z等。 ###6.撤销操作 use “git checkout – …” to discard changes in working如文件readme命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 use “git reset HEAD …” to unstage对于上面的第二种，如果已经add到暂存区，可以先use “git reset HEAD …” ，然后再git checkout – .使他完全撤销更改 版本回退 用git log / git reflog查看commit id git reset –hard [commit id] / git reset –hard [HEAD^] (一个^代表上一个提交) 7.删除文件 git rm 删除工作区和git仓库中的文件 git rm –cached只取消跟踪，本删除本地工作区文件 8.远程仓库 git remote 列出远程服务器的简写 （-v详细） git remote add 添加远程仓库 git clone [url] [name] (可添加自定义仓库名) 克隆，在当前目录下建立一个文件夹 git fetch [remote-name]抓取远程仓库的所有数据如果你使用 clone 命令克隆了一个仓库,命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以,git fetch origin 会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。 git pull 会抓取并自动合并到当前分支 git remote show origin(查看origin仓库的更多信息) git remote rename [原] [新] 远程仓库重命名 git remote rm 远程仓库删除 git分支 （重点）注意，ｇｉｔ还有一个指针HEAD,指向当前分支的指针（也就是当前分支的别名）-git branch 创建分支-git checkout 切换分支 git checkout -b &lt;&gt;创建分支并切换到这个分支上 在你这么做之前,要留意你的工作目录和暂存区里那些还没有被提交的修改,它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。最好的方法是,在你切换分支之前,保持好一个干净的状态。 git merge 将当前分支与name 分支合并（如果时直接上游将快进，不会用冲突） git branch -d 删除分支 master和hotfix直接合并，快进master和iss53为和并提交 合并冲突 git status 查看冲突文件及位置1234567 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt;please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 上面HEADＢ表示当前分支的文件内容，下面表示合并分支的内容 git mergetool第一次使用要设置： git config merge.tool vimdiff 参见这个命令使用图形化界面来合并冲突 git add 标记合并的文件 git commit 合并完成后输入然后显示一个文件，可加如详细信息 分支管理 git branch 显示当前所有分支 git branch -v 查看分支及其最后一次提交 远程分支(remote)/(branch) 形式命名git clone是会自动建立远程分支指针，并以远程的master分支为基础建立本地master分支每次 git fetch d都会更新远程分支指针，本地只能切换到远程分支查看，而不能操作，也就是只要不和远程服务器连接，远程指针就不会移动，但是可以git checkout -b (remote)/(branch)这样以远程分支建立本地分支进行操作 拉取操作 git fetch &lt;远程仓库名&gt;拉取数据并移动远程仓库指针当 git fetch 命令从服务器上抓取本地没有的数据时,它并不会修改工作目录中的内容。它只会获取数据然后让你自己合并。然而,有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个git merge 命令。 git merge origin/serverfix 将这些工作合并到当前所在的分支 git push origin &lt;本地分支的名字&gt;建立远程分支，还本地分支名字一样 git push origin serverfix:serverfix,它会做同样的事 - 相当于它说,“推送本地的 serverfix 分支,将其作为远程仓库的 serverfix 分支”可以通过这种格式来推送本地分支到一个命名不相同的远程分支。如果并不想让远程仓库上的分支叫做 serverfix,可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支 git checkout -b serverfix origin/serverfixgit checkout -b [branch] [remotename]/[branch]fetch到新的远程分支后不会在本地自动建立分支，只会有一个的只读的远程分支，可以执行改命令，会给你一个用于工作的本地分支,并且起点位于 origin/serverfix。 git checkout –track origin/serverfix创建一个跟踪分支（git pull /git push自动识别，） git checkout -b [branch] [remotename]/[branch] 跟踪分支git remote show origin(可查看 git push origin –delete [remote branch] 删除远程分支 最后，一个远程仓库版本回退的操作 git push -f(加上-f 强制执行)现在本地master分支上回退版本，然后加上 -f 强制推到远程仓库 参考：《Pro Git》","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://messi-wpy.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"https://messi-wpy.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://messi-wpy.github.io/tags/Git/"}]},{"title":"抽象工厂模式","slug":"设计模式之抽象工厂模式","date":"2018-06-07T16:00:00.000Z","updated":"2019-11-08T09:51:36.674Z","comments":true,"path":"2018/06/08/设计模式之抽象工厂模式/","link":"","permalink":"https://messi-wpy.github.io/2018/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1. 设计模式之抽象工厂模式 在学习抽象工厂模式前要先了解一下工厂模式，而抽象工厂模式主要就是为了弥补工厂模式的缺点的，抽象~遵循了开闭原则 设计原则之开闭原则 （Open Close Principle，缩写OCP）类、模块、函数等对于拓展是开放的，但是对于修改是封闭的，当软件需要变化时，应该尽量通过拓展的方式来实现变化，而不是通过修改已有的代码来实现。（接口）附上链接 简单工厂模式中没有抽象，直接创建一一对应就不符合开闭原则 而工厂模式已经引入了抽象，工厂方法模式组成： 1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有 的代码。可以看出工厂角色的结构也是符合开闭原则的！ 12345678910111213141516171819202122232425262728293031323334353637381. abstract class BMW &#123; 2. public BMW()&#123; 4. &#125; 5. &#125; 6. public class BMW320 extends BMW &#123; 7. public BMW320() &#123; 8. System.out.println(&quot;制造--&gt;BMW320&quot;); 9. &#125; 10. &#125; 11. public class BMW523 extends BMW&#123; 12. public BMW523()&#123; 13. System.out.println(&quot;制造--&gt;BMW523&quot;); 14. &#125; 15. &#125; 创建工厂类：1. interface FactoryBMW &#123; 2. BMW createBMW(); 3. &#125; 5. public class FactoryBMW320 implements FactoryBMW&#123; 7. @Override 8. public BMW320 createBMW() &#123; 10. return new BMW320(); 11. &#125; 13. &#125; 14. public class FactoryBMW523 implements FactoryBMW &#123; 15. @Override 16. public BMW523 createBMW() &#123; 18. return new BMW523(); 19. &#125; 20. &#125; 最后是抽象工厂模式，他工厂模式有些相似，但是他的特点：抽象工厂模式是工厂方法模式的升级版本，他用来创建 一组相关或者相互依赖的对象。比如宝马320系列使用空调型号A和发动机型号A，而宝马230系列使用空调型号B和发动机型号B，那么使用抽象工厂模式，在为320系列生产相关配件时，就无需制定配件的型号，它会自动根据车型生产对应的配件型号A。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //发动机以及型号 public interface Engine &#123; &#125; public class EngineA extends Engine&#123; public EngineA()&#123; System.out.println(&quot;制造--&gt;EngineA&quot;); &#125; &#125; public class EngineBextends Engine&#123; public EngineB()&#123; System.out.println(&quot;制造--&gt;EngineB&quot;); &#125; &#125; //空调以及型号 public interface Aircondition &#123; &#125; public class AirconditionA extends Aircondition&#123; public AirconditionA()&#123; System.out.println(&quot;制造--&gt;AirconditionA&quot;); &#125; &#125; public class AirconditionB extends Aircondition&#123; public AirconditionB()&#123; System.out.println(&quot;制造--&gt;AirconditionB&quot;); &#125; &#125; 创建工厂类： //创建工厂的接口 public interface AbstractFactory &#123; //制造发动机 public Engine createEngine(); //制造空调 public Aircondition createAircondition(); &#125; //为宝马320系列生产配件 public class FactoryBMW320 implements AbstractFactory&#123; @Override public Engine createEngine() &#123; return new EngineA(); &#125; @Override public Aircondition createAircondition() &#123; return new AirconditionA(); &#125; &#125; //宝马523系列 public class FactoryBMW523 implements AbstractFactory &#123; @Override public Engine createEngine() &#123; return new EngineB(); &#125; @Override public Aircondition createAircondition() &#123; return new AirconditionB(); &#125; &#125; 参考https://blog.csdn.net/jason0539/article/details/44976775 2.android设计模式之策略模式策略模式跟上面工厂模式也有相似，都是利用调用方法是传入不同的接口对象 一般的做法是在一个类里写不同的方法，然后根据实际情况用一连串的if-else或switch来选择对应的方法。这种方法多了后，这个类会变得臃肿，难以修改。(类似于简单工厂模式) 所以如果把不同的策略抽象出来，提供一个统一的接口，为每一个策略写一个实现类，这样客户端就能通过调用接口的不同的实现类来动态替换策略。这就是策略模式 12345678910111213141516171819//定义一类的策略接口interface ComputerStrategy&#123; int computer(int num);&#125;//定义一些不同的类实现接口public class ComputerA implement ComputerStrategy&#123; public int computer(int mun)&#123; .... &#125;&#125;public class ComputerB implement ComputerStrategy&#123; ....&#125;//定义一个方法，引用该接口（可以创一个类在封装一下这个方法） public int Computer（ComputerStrategy computers）&#123; computers.computer（..）;&#125; 更好的代码参考：https://blog.csdn.net/qq_25806863/article/details/68623134","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://messi-wpy.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://messi-wpy.github.io/tags/Java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://messi-wpy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"分治法","slug":"分治法学习","date":"2018-05-18T16:00:00.000Z","updated":"2019-11-08T09:33:51.526Z","comments":true,"path":"2018/05/19/分治法学习/","link":"","permalink":"https://messi-wpy.github.io/2018/05/19/%E5%88%86%E6%B2%BB%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"算法之 分治法 Divide and Conquer 分治法： 分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 使用条件分治法所能解决的问题一般具有以下几个特征： 分解：将大问题的分解成小问题，是这个算法的核心。也是使用分治法的效率保证，如果分解不合理。那么反而会弄巧成拙。 解决：解决问题，便是分解之后的小问题。他们的解决步骤是相同，至少是相似的。所以，分治法中经常用到递归，就是基于这样的目的。 合并：前面那么麻烦的两步，最终的目的仍然是为了解决这个问题。所以需要将分解问题得到的解，合并成最终需要的终极答案，便是这个算法的结束过程。譬如，你使用递归的时候，也需要最后退出的条件。分治法结束条件，就是合并步骤的结束。 所以可以看出分治法与递归联系紧密，时常一起出现，但也有区别，对于分治法，一定要注意会有和这一步，但有时在递归的过程中自动出现和这一步，不用太区分。要理解分治的思想。 主要应用 二分搜索： 快速排序： 分：找到一个基准数；把小于这个数的数都放到左边，把大于这个数的数都放到右边； 解：递归快排 组合：因为当”求解”步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，”组合”步骤无须做什么，可看作是空操作 大整数乘法： leetcode题目分析： 53maximum-subarray: 1 分解：这个数组只能出现在三个位置：从中间分，要么完全在左边，要么完全在右边，要么穿过中间，所以分三部分求最大 2 求解：如果在左边或右边继续分，最后只剩一个数返回，对于穿过中间的，分成两部分求最大，每次都如此。 3 组合：每次返回左边，右边，中间这三个中最大的 1234567891011121314151617181920212223242526class Solution &#123; public int maxSubArray(int[] nums) &#123; return findMax(nums,0,nums.length-1); &#125; public static int findMax(int []num,int left,int right)&#123; if (left&gt;=right)return num[left]; int mid=(left+right)/2; //寻找左边最大 int lmax=findMax(num,left,mid-1); //寻找右边最大 int rmax=findMax(num,mid+1,right); //寻找中间最大，并分成两部分，找从中间左边连续最大，中间到右边连续最大，最后加起来 int mmax=num[mid],t=mmax; for (int i=mid-1;i&gt;=left;i--)&#123; t+=num[i]; mmax=Math.max(mmax,t); &#125; t=mmax; for (int i=mid+1; i&lt;=right; i++)&#123; t+=num[i]; mmax=Math.max(mmax,t); &#125; //合并 return Math.max(mmax,Math.max(lmax,rmax)); &#125;&#125; 241. Different Ways to Add Parentheses: 1 分：每次遇到符号，分成前后两部分，并记录该符号 2 解：让左边的运算的所有结果去分别加后边运算的所有结果，分解直到只有两个数子，让他们运算， 3 组合：每次的结果都计入数组返回。 123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for (int i=0; i&lt;input.length(); i++) &#123; char ch = input.charAt(i); if (ch == &apos;+&apos; || ch == &apos;-&apos; || ch == &apos;*&apos;) &#123; List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0,i)); List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1,input.length())); for (int l : left) &#123; for (int r : right) &#123; switch(ch) &#123; case &apos;+&apos; : res.add(l+r); break; case &apos;-&apos; : res.add(l-r); break; case &apos;*&apos; : res.add(l*r); break; &#125; &#125; &#125; &#125; &#125; if (res.size() == 0) res.add(Integer.valueOf(input)); return res; &#125;&#125; 215. Kth Largest Element in an Array:这道题就只要先快速排序一下就可以找到了","categories":[{"name":"算法","slug":"算法","permalink":"https://messi-wpy.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://messi-wpy.github.io/tags/leetcode/"},{"name":"分治法","slug":"分治法","permalink":"https://messi-wpy.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"}]},{"title":"java 泛型","slug":"Java泛型分享","date":"2018-04-19T16:00:00.000Z","updated":"2019-11-16T10:27:20.566Z","comments":true,"path":"2018/04/20/Java泛型分享/","link":"","permalink":"https://messi-wpy.github.io/2018/04/20/Java%E6%B3%9B%E5%9E%8B%E5%88%86%E4%BA%AB/","excerpt":"","text":"泛型，一个孤独的守门者 关于泛型的具体细节这篇博客我觉得讲得十分详细，所以我分享一下我学习中的一些难点与体会。 1.学习泛型要先掌握java的类型转换机制java引用数据类型转换，由于继承，java自然的向上转换，父类转换为子类需要特定条件。2.作用：泛型，就是参数类型化，把一个类型作为参数传递进去，而把他成为守门人，很好的形容了泛型的功能。在没有泛型之前，一般都是用继承，object这个基类来实现但是这样不管加入任何类型都可以，所以需要泛型这个守门人，检测传入的类型，可以在编译阶段查出错误。 12345678List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);&#125; 崩溃java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 3.类型擦出，理解反省的这个特性才能完全掌握泛型。泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，。泛型全部转换为object，与普通类没什么区别（如有类型限定则转换为限定类型）所以说，泛型是一个守门人，在编译的时候提醒你传入什么类型，相应的，我们也可以利用反射，我们绕过编译器去调用 add 方法 4.通配符？Java 泛型通配符和类型限定关于上限与下限的读取使用说明 我认为很好的例子 12345678910111213141516public static void count(Collection&lt;? super Integer&gt; ints, int n)&#123; for (int i = 0; i &lt; n; i++) ints.add(i);&#125;public static void main(String[] args) &#123; List&lt;Integer&gt;ints = new ArrayList&lt;&gt;(); count(ints, 5); assert ints.toString().equals(&quot;[0, 1, 2, 3, 4]&quot;); List&lt;Number&gt;nums = new ArrayList&lt;&gt;(); count(nums, 5); nums.add(5.0); assert nums.toString().equals(&quot;[0, 1, 2, 3, 4, 5.0]&quot;); List&lt;Object&gt;objs = new ArrayList&lt;&gt;(); count(objs, 5); objs.add(&quot;five&quot;); assert objs.toString().equals(&quot;[0, 1, 2, 3, 4, five]&quot;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://messi-wpy.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://messi-wpy.github.io/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-31T16:00:00.000Z","updated":"2019-11-08T09:50:30.069Z","comments":true,"path":"2018/01/01/hello-world/","link":"","permalink":"https://messi-wpy.github.io/2018/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}